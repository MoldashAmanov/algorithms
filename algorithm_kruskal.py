
# список ребер графа (длина, вершина 1, вершина 2)
R = [(13, 1, 2), (18, 1, 3), (17, 1, 4), (14, 1, 5), (22, 1, 6),
     (26, 2, 3), (22, 2, 5), (3, 3, 4), (19, 4, 6)]

Rs = sorted(R, key=lambda x: x[0])
U = set() # список соединенных вершин
D = {} # словарь списка изолированных групп вершин
T = [] # список ребер остова

for i in Rs:
    if i[1] not in U or i[2] not in U: # проверка для исключения циклов в остове
        if i[1] not in U and i[2] not in U: # если обе вершины не соединены
            D[i[1]] = [i[1], i[2]] # формируем в словаре ключ с номерами вершин
            D[i[2]] = D[i[1]] # и связываем их с одним и тем же списком вершин
        else:
            if not D.get(i[1]): # если в словаре нет первой вершины, то
                D[i[2]].append(i[1]) # добаляем в список первую вершину
                D[i[1]] = D[i[2]] # и добавляем ключ с номером первой вершины 
            else:
                D[i[1]].append(i[2]) # все то же самое делаем со второй вершиной
                D[i[2]] = D[i[1]]

        T.append(i) # добавляем ребра в остов
        U.add(i[1]) # добавляем вершины в множество U
        U.add(i[2])

for i in Rs: # проходим по ребрам второй раз и объединяем разрозненные группы вершин
    if i[1] in D[i[1]] and i [2] not in D[i[1]]: # если вершины принадлежат разным группам, то объединяем 
        T.append(i) # добавляем ребро в остов
        gr1 = D[i[1]]
        D[i[1]] += D[i[2]] # объединяем списки двух вершин
        D[i[2]] += gr1

print(T)